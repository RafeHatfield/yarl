## Engine Entrypoints & IO Flow (current state)

- `engine.py`: Main interactive/bot entry. Sets SDL headless flag, initializes libtcod root + 3-console layout, parses CLI flags, and hands a fully constructed game (player/entities/map/message_log/game_state) plus consoles and constants to `engine_integration.play_game_with_engine()`. Bot soak delegates early to `engine/soak_harness.py`.
- `engine_integration.play_game_with_engine()`: Bridging loop that wires Renderer/InputSource protocols to the ECS/system world. It builds `GameEngine`, registers systems, initializes state/FOV/camera, creates `ActionProcessor` + TurnManager/TurnController, then drives the turn loop: input_source → action processing → system updates → rendering. Bot/autoplay and manual modes share this path.
- `engine/soak_harness.py`: Session runner for bot soak. Initializes libtcod root once, resets singletons between runs, creates per-run consoles/game state, and calls `play_game_with_engine()` for each run. Handles telemetry/metrics aggregation and CSV/JSONL outputs.
- Scenario harness (`services/scenario_harness.py` et al.): Separate runner for deterministic simulations and metrics. It builds game state via loaders and uses existing action/turn pipeline but currently does not depend on the libtcod entrypoints; left untouched by this change.
- IO abstractions: `io_layer/interfaces.py` defines `Renderer` and `InputSource`. Concrete implementations (`ConsoleRenderer`, `KeyboardInputSource`, `BotInputSource`) are created in `engine_integration.create_renderer_and_input_source()`. Rendering is read-only; inputs produce `ActionDict` fed into the same action processor/turn pipeline.
